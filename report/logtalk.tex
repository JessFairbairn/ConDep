\documentclass[report]{subfiles}
    

\begin{document}

\subsection{Logical Programming}

I chose to write the logical programming parts of the system in Prolog, due to it's relative simplicity and common usage. The Logtalk extension language was also used due to it's object orientation features- this transpiles into pure Prolog, and primarily uses Prolog syntax.

The object orientated nature of Logtalk allowed universal domain rules be written in one file and reused for different scenarios. 



\lstset{language=Prolog,basicstyle=\footnotesize,
deletekeywords={time},
morekeywords={public,object,end_object},
frame=single}

\begin{lstlisting}[
    caption={The `condep' object, which can be extended for individual simulations, maintaining the universal domain rules},]
:- object(condep).

:- public(
    [
    inside/3, outside/3,
    isTime/1, injestEvent/1, expelEvent/1, isEvent/1,
    justBefore/2, justAfter/2,
    actorOfEvent/2, objectOfEvent/2
    ]
).
% Event definitions

% Different kinds of event are still instances of an event
isEvent(B) :- ::expelEvent(B).
isEvent(B) :- ::ingestEvent(B).


isTime(Time) :-
    ::justAfter(Time,Event),
    ::isEvent(Event).

isTime(Time) :-
    ::justBefore(Time,Event),
    ::isEvent(Event).

actorOfEvent(_ActorOfEvent,_Event).
objectOfEvent(_ObjectOfEvent, _Event).

% Physical definitions

% Establishing common sense facts about the ingest
% and expel events, and the relation of being `inside'
inside(Food,Eater,T) :-
    ::isTime(T),
    ::injestEvent(InjEvent),
    ::justAfter(T,InjEvent),
    ::actorOfEvent(Eater, InjEvent),
    ::objectOfEvent(Food, InjEvent).

inside(Food,Eater,T) :-
    ::isTime(T),
    ::expelEvent(InjEvent),
    ::justBefore(T,InjEvent),
    ::actorOfEvent(Eater, InjEvent),
    ::objectOfEvent(Food, InjEvent).


outside(Food,Container,T) :-
    ::isTime(T),
    ::expelEvent(InjEvent),
    ::justAfter(T,InjEvent),
    ::actorOfEvent(Container, InjEvent),
    ::objectOfEvent(Food, InjEvent).

outside(Food,Container,T) :-
    ::isTime(T),
    ::injestEvent(InjEvent),
    ::justBefore(T,InjEvent),
    ::actorOfEvent(Container, InjEvent),
    ::objectOfEvent(Food, InjEvent).

:- end_object
    
\end{lstlisting}

    To express the state of an input scenario, a Python module is called which expresses a CD Event in terms of Prolog, saving this into a logtalk file which inherits from the universal conceptual dependency logic. This had to include `super calls' in Logtalk logic in the header, ensuring that predicates added to the state file didn't overwrite the logic of the `condep' class. The predicates were also tagged with discontiguous statements, to avoid complications in the automated generation of predicates out of order. 

\begin{lstlisting}[caption={An example `state', inhereiting from the `condep' Logtalk object},]
:- object(state, extends(condep)).

% defining predicates as discontiguous, and inherited
:- discontiguous(actorOfEvent/2).
:- discontiguous(objectOfEvent/2).
:- discontiguous(justBefore/2).
:- discontiguous(justAfter/2).

actorOfEvent(A,B) :- ^^actorOfEvent(A,B).
objectOfEvent(A,B) :- ^^objectOfEvent(A,B).
justBefore(A,B) :- ^^justBefore(A,B).
justAfter(A,B) :- ^^justAfter(A,B).

% Generated Prolog predicates
expelEvent(myEvent).

actorOfEvent(myEvent, blackHole).
objectOfEvent(myEvent, barbara).

justBefore(timeBeforeEvent, myEvent).
justAfter(timeAfterEvent, myEvent).		

:- end_object.
\end{lstlisting}

After a Logtalk file is generated, a Logtalk instance is run which allows the user to query the scenario- at this time these must be expressed in Prolog. A query which could be asked about the above state is:
\begin{lstlisting}
:? state::outside(barbara, blackHole, timeBeforeEvent).
\end{lstlisting}
to which Logtalk would answer ``no'' (or ``false'')- as this is an EXPEL event, it's logical that Barbara is inside the blackHole before she can be expelled.


Due to the inherited nature of predicates in this system, there may be multiple `definitions' of a predicate (the general definition of the predicate, and then a statement that it applies to an instance in the scenario). By default, Prolog's behaviour here is to list the possible outcomes- for a question asking `Is X true?', it will list `true' then `false' for each different definition. To avoided this problem the \textit{once/1} predicate can be used to check if at least one of the definitions is satisfied.

\subsubsection{Example: Inference of missing events}
\label{logtalkinference}

Here we will demonstrate an inference made in our logtalk implementation. It states that:
\begin{itemize}
    \item If an object is moving away from a mass at one point in time
    \item and if it is absorbed by that mass at a later point in time
    \item \ldots then it follows a PROPEL event occurred between those two events to change the object's direction of movement
\end{itemize}
This is a consequence of Newton's First law of motion, which states that an object will continue to move in the same direction at the same speed indefinitely until another force acts upon it. The following code checks if there should be an event between two specified events:

\begin{lstlisting}
missingEventBetween(FirstEvent, InjEvent) :-

    ::injestEvent(InjEvent),
    ::actorOfEvent(Mass, InjEvent),
    ::objectOfEvent(Obj, InjEvent),

    ::justAfter(T1, FirstEvent),
    ::movingAwayFrom(Obj, Mass, T1),
    ::beforeEvent(T1,InjEvent) ; ::afterEvent(InjEvent, T1).
\end{lstlisting}

The steps for this predicate ensure:
\begin{itemize}
    \item The mass INGESTs the object 
    \item At a time just after the first event, the object is moving away from the mass
    \item The events occur in the correct order
\end{itemize}

This predicate doesn't require that there isn't already an event between the two.

\end{document}